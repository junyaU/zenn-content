---
title: "自作OSにネットワーク機能を実装してpingに応答させる"
emoji: "🏓"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

## はじめに
自作しているOSにネットワーク機能とpingコマンドの実装を行いました。

自作OSにネットワーク機能を追加し、最終的に **ping が通るところまで**を実装しました。
しかし、ARP・IP・ICMP といった基礎プロトコルの処理まで含めると記事が長くなるため、全体を三回の連載として分割して解説します。
本記事ではその第1回として、ホスト（WSL2）から自作 OS に送られる ARP Request と ICMP Echo Request（ping）に応答するまでの処理に焦点を当てます。
扱う範囲はOSI参照モデルの1〜3層に相当します。

## 前提知識
本記事では以下の前提知識を持っていることを想定しています。
- OSI参照モデルの1〜3層の基礎知識
- IPアドレスとMACアドレスの違いと役割
- pingコマンドの基本的な理解
## やったことの全体像
今回は、自作 OS にネットワーク機能を追加し、最終的にホスト環境（WSL2）からの ping に応答できるところまでを実装しました。
- ARP リクエストへの応答（MAC アドレス解決）
- ICMP Echo Request（ping）への応答

実際に自作 OS 上で行っている処理の全体像は次のとおりです。
```
┌───────────┐
│   virtio-net  │  ← QEMUの仮想 NIC
└───────┬─────┘
        │ パケット受信
        ▼
┌───────────┐
│   OSカーネル   │
│  ・virtqueue からパケット受け取り
│  ・ネットワークプロセスへ転送
└───────┬─────┘
        │
        ▼
┌───────────┐
│ network プロセス │
└───────┬─────┘
        │
        ├── ARP パケット？
        │        └→ ARP Reply を生成して送信
        │
        └── IP パケット？
                └── ICMP Echo Request？
                        └→ ICMP Echo Reply を生成して送信
```
virtio-net という 最下層の仮想 NIC からパケットを受信し、OS 内でヘッダを順に解析しながら、プロトコルごとに応答を返す最小限のネットワークスタックを実装しています。
本記事では、
- virtio-net からパケットを受け取る仕組み
- ARP / ICMP 各ヘッダの解析方法
- 応答パケット（ARP Reply / ICMP Echo Reply）の組み立て手順

といった **ping に応答するまでに必要な最低限のネットワーク処理の流れ**を順を追って解説します。

## virtio-netからパケット受信
### virtio-netとは
virtio-netは、Virtioという準仮想化フレームワーク上で提供される仮想NICです。
Virtioそのものの仕組みについては、以前公開した以下の記事で詳しく解説しています
https://zenn.dev/junjunjunjun/articles/27ede76931cc85
本記事では、**OS にネットワークパケットを届けてくれる仮想NIC」**として理解しておけば問題ありません。
### 設定
virtio-net を利用するために、ホスト側で TAPデバイスを作成し、IPアドレスを割り当てます。
```bash
# TAPデバイスの作成
ip tuntap add dev tap0 mode tap

# IPアドレス設定
ip addr add 192.168.100.1/24 dev tap0

# デバイス有効化
ip link set tap0 up

# パケット転送を有効化
sysctl -w net.ipv4.ip_forward=1
```
この設定により、`tap0` という名前のTAPデバイスに、`192.168.100.1/24` のプライベートIPアドレスを割り当てた状態になります。
QEMU の virtio-net デバイスをこの tap0 に接続することで、自作 OS がホストと同一ネットワーク上に存在するように振る舞うことができます。

QEMU の起動オプションは以下のようになります。
```bash
qemu-system-x86_64 \
    -netdev tap,id=net0,ifname=tap0,script=no \
    -device virtio-net-pci,netdev=net0,mac=52:54:00:12:34:56 \
```
MAC アドレスは任意ですが、ローカルネットワーク内で衝突しない値を指定する必要があります。

### パケットを取り出してnetworkプロセスに送信
virtio-net デバイスは、受信パケットをカーネルが用意したバッファ（virtqueue）に直接書き込みます。
カーネル側では以下を行っています。

1. 受信キュー（receive queue）に登録したバッファへ、virtio-net がパケットを書き込む
2. デバイスからの通知（※今回はポーリング）で、パケットが到着したことを検出
3. virtqueue からパケットを回収
4. パケット内容を network プロセスへ転送

この段階ではまだ ARP や ICMP の解析は行わず、
**受信したパケットをnetworkプロセスに届ける**という最小限の役割だけを担っています。


<!-- ホストからpingを送信し、自作OS側でパケットを受け取れている様子の動画をここに貼る -->
ホスト側から以下のコマンドを実行すると、自作OSがパケットを受信している様子を確認できます。
```bash
ping 192.168.100.1
```
ただし現時点では、ARP 応答や ICMP Echo Reply を実装していないため、
ホストからは 送信はできても応答が返ってこずタイムアウトする 状態です。

<!-- wiresharkのキャプチャ -->

## イーサネットフレームの解析
networkプロセスに届いたパケットは、以下のような階層構造になっています。
<!-- イーサネットフレーム、Arpパケット、ICMPパケットの図解 -->

解析は、OSI参照モデルの下位層から順に行います。（これをデカプセル化と呼びます）
まずは最下層のデータリンク層（レイヤー2）にあたる **イーサネットフレーム** の解析から始めます。

### イーサネットフレームとは
イーサネットフレームは、イーサネットネットワーク上でデータを送受信するための基本単位です。
以下のような構造を持っています。
```cpp
struct EthernetFrame {
	uint8_t dst_mac[6]; ///< Destination MAC address
	uint8_t src_mac[6]; ///< Source MAC address
	uint16_t ethertype; ///< EtherType
	uint8_t payload[];	///< Frame payload
} __attribute__((packed));
```

各フィールドの役割は以下の通りです。
- `dst_mac` : 宛先の MAC アドレス
- `src_mac` : 送信元の MAC アドレス
- `ethertype` : ペイロードのプロトコルを示す識別
- `payload` : 上位層のデータ（ARPパケットやICMPパケットなど）

`ethertype` の値によって、ペイロードにどのプロトコルのデータが格納されているかを判別できます。
主な値は以下の通りです。
- `0x0806` : ARP（Address Resolution Protocol）
- `0x0800` : IPv4
- `0x86DD` : IPv6

### イーサネットフレームの解析手順
networkプロセスでは、まずイーサネットフレームのヘッダを解析し、`ethertype` フィールドを確認することで、上位層のプロトコルを判別します。

```cpp
void handle_recv_packet(const Message& m)
{
	const EthernetFrame* frame =
			reinterpret_cast<const EthernetFrame*>(m.data.net.packet_data);

	switch (static_cast<EthernetFrameType>(ntohs(frame->ethertype))) {
		case EthernetFrameType::ARP:
			process_arp(*reinterpret_cast<const ARPPacket*>(frame->payload));
			break;
		case EthernetFrameType::IPV4:
			process_ipv4(*reinterpret_cast<const IPv4Header*>(frame->payload));
			break;
		case EthernetFrameType::IPV6:
			LOG_ERROR("IPv6 packet received");
			break;
		default:
			LOG_ERROR("Unknown Ethertype");
			break;
	}
}
```

これにより、受信したパケットが ARP なのか IP なのかを判別し、それぞれの解析処理に進むことができます。


## ARPリクエストパケットに応答
### ARPとは
ARP（Address Resolution Protocol）は、IPアドレスから対応するMACアドレスを取得するためのプロトコルです。
イーサネットなどのデータリンク層で実際に通信を行うためには、送信先の MAC アドレスが必要です。
しかし、通常私たちが指定するのは IP アドレスであり、MAC アドレスは自動的に解決される必要があります。
この「IP アドレス → MAC アドレス」の変換を行うのが ARP の役割です。

### ARPの動作フロー
ホストが自作 OS に ping を送信する際も、まずは以下の流れで ARP による MAC アドレス解決が行われます。

1. **ARP Request のブロードキャスト**
   ホストAは、宛先IP（例：192.168.100.2）を含んだ ARP Request をブロードキャスト送信します。
   この時、イーサネットフレームの宛先MACアドレスには `FF:FF:FF:FF:FF:FF`（ブロードキャストアドレス）が指定され、ローカルネットワーク内の全デバイスがこのパケットを受信します。
2. **該当デバイスのみが応答**
   各デバイスは ARP Request 内の `target_ip` フィールドを確認し、「このIPアドレスは自分のものか？」を判定します。
   一致したデバイス（ホストB）のみが ARP Reply を返し、それ以外のデバイスはパケットを破棄します。
3. **MAC アドレスの学習**
   ホストAは、受け取った ARP Reply から ホストB の MAC アドレスを取得し、ARPテーブル（キャッシュ）に保存します。
   以降の通信では、この情報を使って直接パケットを送信できるようになります。

この仕組みによって、IP アドレス → MAC アドレス という変換が行われ、データリンク層での通信が可能になります。

:::message
先ほどのpingコマンド実行時に `Destination Host Unreachable` エラーが発生していたのは、ホスト側で ARP による MAC アドレス解決が完了せず、自作OSの MAC アドレスが分からなかったためです。
:::

### ARPパケットの構造
ARPパケットは以下のような構造を持っています。
```cpp
struct ARPPacket {
	uint16_t hw_type;		///< Hardware Type
	uint16_t protocol_type; ///< Protocol Type
	uint8_t hw_size;		///< Hardware Address Length
	uint8_t protocol_size;	///< Protocol Address Length
	uint16_t opcode;		///< Operation Code
	uint8_t sender_mac[6];	///< Sender MAC Address
	uint32_t sender_ip;		///< Sender IP Address
	uint8_t target_mac[6];	///< Target MAC Address
	uint32_t target_ip;		///< Target IP Address
} __attribute__((packed));
```

各フィールドの役割は以下の通りです。
- `hw_type` : ハードウェアタイプ（Ethernet = 1）
- `protocol_type` : プロトコルタイプ（IPv4 = 0x0800）
- `hw_size` : ハードウェアアドレス長（MAC アドレスは 6 バイト）
- `protocol_size` : プロトコルアドレス長（IPv4 アドレスは 4 バイト）
- `opcode` : 操作コード（REQUEST = 1, REPLY = 2）
- `sender_mac` / `sender_ip` : 送信元の MAC アドレスと IP アドレス
- `target_mac` / `target_ip` : 宛先の MAC アドレスと IP アドレス

ARP Request では `target_mac` は未知の値（通常は `00:00:00:00:00:00`）であり、ARP Reply でこのフィールドに正しい MAC アドレスが格納されます。

### ARP Request の解析
イーサネットフレームから取り出した ARP パケットを解析し、`opcode` フィールドを確認することで、リクエスト（REQUEST）かリプライ（REPLY）かを判別します。

```cpp
void process_arp(const ARPPacket& arp_packet)
{
	switch (static_cast<ARPOpcode>(ntohs(arp_packet.opcode))) {
		case ARPOpcode::REQUEST:
			handle_arp_request(arp_packet);
			break;
		case ARPOpcode::REPLY:
			handle_arp_reply(arp_packet);
			break;
		default:
			LOG_ERROR("Unknown ARP opcode");
			break;
	}
}
```

ping に応答するためには、ARP Request に対して ARP Reply を返す必要があります。
次は、その ARP Reply の構築方法を見ていきます。

### ARP Reply の構築と送信
ARP Request を受信したら、以下の処理を行います。

```cpp
void handle_arp_request(const ARPPacket& arp_packet)
{
    // 自分宛てのリクエストか確認
	if (arp_packet.target_ip != htonl(hw::virtio::MY_IP)) {
		return;
	}

    // 送信元のMACアドレスをARPテーブルに登録（後続の通信で使用）
	uint32_t sender_ip = ntohl(arp_packet.sender_ip);
	arp_table.add(sender_ip, arp_packet.sender_mac);

	void* buf;
	ALLOC_OR_RETURN(buf, sizeof(ARPPacket), kernel::memory::ALLOC_ZEROED);

    // ARP Replyの構築
	ARPPacket& reply = *reinterpret_cast<ARPPacket*>(buf);
	reply.hw_type = htons(1);			 // Ethernet
	reply.protocol_type = htons(0x0800); // IPv4
	reply.hw_size = MAC_ADDR_SIZE;
	reply.protocol_size = 4;
	reply.opcode = htons(static_cast<uint16_t>(ARPOpcode::REPLY));

    // sender と target を入れ替える
	reply.sender_ip = arp_packet.target_ip;
	reply.target_ip = arp_packet.sender_ip;
	memcpy(reply.sender_mac, hw::virtio::mac_addr, MAC_ADDR_SIZE);
	memcpy(reply.target_mac, arp_packet.sender_mac, MAC_ADDR_SIZE);

    // イーサネットフレームにのせて送信
	transmit_ethernet_frame(arp_packet.sender_mac, EthernetFrameType::ARP, &reply,
							sizeof(ARPPacket));
}
```

処理の流れは以下の通りです。

1. **宛先IPアドレスの確認**
   `target_ip` が自分の IP アドレスと一致するかを確認します。一致しない場合は無視します。
2. **ARP テーブルへの登録**
   送信元の IP アドレスと MAC アドレスのペアを ARP テーブルに保存します。
   これにより、後続の通信で相手の MAC アドレスを再度問い合わせる必要がなくなります。
3. **ARP Reply の構築**
   Request の送信元/宛先を入れ替え、自分の MAC アドレスを `sender_mac` に設定します。
4. **送信**
   構築した ARP Reply を、イーサネットフレームに載せてホストに返送します。

この処理により、ホスト側は自作OSの MAC アドレスを学習し、以降の通信（ICMP Echo Request など）を送信できるようになります。

## ICMPリクエストパケットに応答
### ICMPとは
### エコーリクエストの解析
### エコーリプライの構築
### pingの疎通確認
## ハマったポイント
## おわりに
## 参考資料